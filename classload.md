###虚拟机类加载机制
虚拟机设计团队把类加载器阶段中的“通过一个类的全限定名来获取描述此类的二进制字节流”这个动作放到java虚拟机外部去实现。

####类与类加载器
类加载器虽然只用于实现类的加载动作，但它在java程序中起到的作用却远远不限于类加载阶段，对于任意一个类，都需要由加载它的类加载器和这个类本身一同
确立其在Java虚拟机中的唯一性,每个类加载器，都拥有一个独立的类名称空间，
通俗一点 比较两个类是否相等，只有在这两个类是由同一个类加载器加载的前提下才有意义，否则即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要
加载它们的类加载器不同，那么两个类就必定不相等。
这里的相等 包括class .equals isassignableform() isinstance() 也包括instanceof关键字对对象所属关系的判定等情况。

####双亲委派模型
java虚拟机的角度来讲，只有两种不同的类加载器，一种是启动类加载器(Bootstrap Classloader),C++实现，是虚拟机自身的一部分
另一种就是所有其他的类加载器,由java语言实现 独立于虚拟机外部，并且全部继承抽象类java.lang.ClassLoader.
启动类加载器
扩展类加载器
应用程序类加载器

####双亲委派模型
如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每个层次的类加载器都是如此，因此
所有的加载请求最终都应该传递到顶层的启动类加载器中，只有父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。
例如java.lang.Object类，它存放在rt.jar中，无论哪一个类加载器要加载这个类，最终都委派给处于模型最顶端的启动类加载器，因此Object类在程序的各种类加载器中都是同一个类。

####破坏双亲委派模型
JNDI是java的标准服务，它的代码由启动类加载器去加载，jndi需要调用由独立厂商实现并部署在应用程序的classpath下的JNDI接口提供者，启动类加载器不认识这些代码。

线程上下文类加载器（Thread Context ClassLoader）这个类加载器可以通过java.lang.Thread类的setContextClassLoader()方法进行设置。

父类加载器请求子类加载器去完成类加载操作
JNDI JDBC JCE 

OSGI 热部署
